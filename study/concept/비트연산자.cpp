#include <string>
#include <vector>

using namespace std;

long long solution(int a, int b) {
    long long answer = 0;
    if (a > b) a ^= b ^= a ^= b;
    answer = (long long)b * -~b / 2 - (long long)a * ~- a / 2;
    return answer;
}



비트 연산자와 등차수열 합 공식을 한 번에 섞어 씀


1. if (a > b) a ^= b ^= a ^= b;


a와 b 스왑(XOR 스왑 트릭)
a ^= b;

b ^= a;

a ^= b;

이 순서로 하면 임시 변수 없이 a와 b의 값이 바뀜.
여기서는 한 줄에 모두 넣어서 한 번에 처리.

즉, a > b라면 a와 b의 값을 바꾼다
(a가 항상 더 작거나 같게 보장)


2. 등차수열 합 공식
a~b 사이의 합은 :
sum = (b * (b + 1) / 2) - (a - 1) * a / 2


answer = (long long)b * (b + 1) / 2 - (long long)a * (a - 1) / 2;
여기서 비트 연산 트릭
- ~b는 b + 1
(비트 NOT(~b)은 - (b + 1), 거기에 –(–(b + 1)) 하면 b + 1로 복원됨)

~- a는 a - 1
(마찬가지로, ~a는 –(a + 1), 즉 ~(a)는 - (a + 1), 따라서 ~- a는 a - 1)

즉,

b * -~b → b * (b + 1)

a * ~- a → a * (a - 1)

3. 최종 코드 의미
즉,

항상 a <= b가 되도록 swap

그리고 1부터 b까지의 합에서 1부터(a - 1)까지의 합을 빼서, a~b까지의 합을 구함

4. 정리 & 예시
예를 들어,

a = 3, b = 5일 때 :

b * -~b / 2 = 5 * 6 / 2 = 15

a * ~- a / 2 = 3 * 2 / 2 = 3

차이 = 12 (3 + 4 + 5)

한 줄 요약
비트연산자 - ~, ~- 로 + 1, -1 트릭

XOR로 a, b 스왑

등차수열 합 공식





1. 비트 연산자 - ~, ~- 의 개념
- ~b == b + 1
~는 비트 NOT 연산자

~b는 b의 모든 비트를 반전시킴

예) 5 (0b0101) → ~5 (0b1010...1010, 즉 - 6)

C++에서 ~b = -b - 1

- ~b는

~b를 한 뒤에 부호를 바꾼 것

즉, -(~b) = -(-b - 1) = b + 1

~- a == a - 1
- a는 음수로 바꾼 것

~(-a)는

- a의 비트 반전 = -(-a) - 1

= a - 1

정리
- ~x == x + 1

~- x == x - 1

예시

int b = 5;
cout << -~b << endl; // 6
int a = 3;
cout << ~- a << endl; // 2
2. XOR 스왑의 안전성
a ^= b; b ^= a; a ^= b; 는 왜 동작하나 ?
이건 임시 변수 없이 값을 교환하는 트릭

단, a와 b가 동일한 변수일 때(동일한 주소일 때)는 버그 발생!
(하지만 이 문제에서는 입력 파라미터라 상관없음)

작동 원리 예시
예 : a = 3, b = 5

연산	a	b
a ^= b(3 ^ 5 = 6)	6	5
b ^= a(5 ^ 6 = 3)	6	3
a ^= b(6 ^ 3 = 5)	5	3

주의점
자기 자신과 XOR 스왑할 때(a, b가 같은 변수) 위험함

그 외에는 문제없음(파라미터가 값 복사라서 안전!)

3. 등차수열 공식 : 왜 저게 맞는지 ?
등차수열의 합 공식
1부터 n까지 더하는 합 :
sum(n) = n * (n + 1) / 2

a~b까지 더하는 합은 ?

1b의 합에서 1(a - 1)의 합을 빼면 됨!

즉, sum(a~b) = sum(b) - sum(a - 1)

공식 그대로 대입!

예시
a = 3, b = 5

sum(5) = 5 * 6 / 2 = 15

sum(2) = 2 * 3 / 2 = 3

sum(3~5) = 15 - 3 = 12

실제로 3 + 4 + 5 = 12
공식이 맞음을 확인할 수 있음.

4. 실제 코드 비교(for문 vs 공식)

#include <iostream>
using namespace std;

int main() {
    int a = 3, b = 5;
    long long sum1 = 0;
    for (int i = a; i <= b; i++) sum1 += i;

    if (a > b) swap(a, b);
    long long sum2 = (long long)b * (b + 1) / 2 - (long long)a * (a - 1) / 2;

    cout << "for문: " << sum1 << endl;
    cout << "공식: " << sum2 << endl;
    return 0;
}
// 둘 다 12 출력
요약
- ~x → x + 1, ~- x → x - 1 (비트연산자 트릭)

XOR 스왑은 임시 변수 없이 값 교환, but 같은 변수면 위험

등차수열 합 공식으로 for문 없이 빠르게 계산
(공식: sum(b) - sum(a - 1))

추가적으로 궁금한 포인트 있으면 더 질문해도 돼!
(실행 결과, 디버깅, 내부 원리 등 전부 가능)









이 코드의 핵심 요약
a, b 중 더 큰 값을 앞으로 오게 함(XOR 스왑)

if (a > b) a ^= b ^= a ^= b;

임시 변수 없이 a, b 값 바꿈.

a~b까지의 합은 등차수열 합 공식으로 바로 계산

sum = (b * (b + 1) / 2) - (a * (a - 1) / 2)

1부터 b까지의 합에서 1부터(a - 1)까지의 합을 뺌.

비트 연산자 트릭 사용

- ~b → b + 1

~- a → a - 1

공식에 그대로 대입해서 더 짧고 빠르게 계산!

한줄 요약
a~b까지의 합은 등차수열 합 공식으로 빠르게 구할 수 있고,
비트 연산자 트릭(-~b, ~- a)으로 식을 더 짧게 쓴 고인물 스타일 코드다.

필요하면 더 요약하거나, 코드 템플릿 바로 뽑아줄 수도 있음!