int main()
{
	// 정수와 실수는 표현하는 방식 자체 메모리를 다루는 방식 자체가 다르다
	
	int a = 4 + 4.0;

	// 부동소수점

	// 실수 표현바익은 정밀도에 의존한다.
	// 따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다
	
	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자
	float f = 10.2415f + (float)20;

	// 실수를 상수로 적을 경우 소수점 뒤에
	// f 를 붙이는 것은 float, 4바이트 단위로 보겠다 
	// f 를 안 붙이는 것은 double, 8바이트 단위로 보겠다 
	// 4바이트로 볼 것인지 8바이트로 볼 것인지 정해줌
	


	
	// 연산자
	// 대입 연산자, =


	// 산술 연산자
	// +,-,*,		/,%(모듈러스, 나머지 연산자, 피연산자가 모두 정수일 때)
	// ++, -- (증감 연산자)(한 단계 증가 또는 감소)
	int data = 10 + 10;
	// data + 20; 이렇게 하면 data 값이 증가하지 않음
	// 그 결과를 받아서 다시 data 안으로 집어넣어라
	// data = data + 20; 밑이랑 같은얘기
	data += 20;


	// 나누기 연산은 피연산자가 정수냐 실수냐에 따라서 두가지 케이스가 나옴

	// data = 10 / 3; data에 3 저장
	// data = 10 % 3; data에 1 저장

	// data = 10. % 3.; 컴파일 오류(실수)
	// data = 10 % 3.; 컴파일 오류

	// data = 10. / 3.; 경고가 뜬다 

	data = (int)(10. / 3.); //int 로 바꿔서 데이터에 집어넣겠다





	data = 0;

	++data; //전위(전치)
	data++; //후위(후치) : 모든 연산자를 통틀어서 가장 나중에 수행됨, 대입연산자 보다 늦음
	//연산자 우선순위가 달라짐
	
	data = 0;
	
	a = 10;
	data = a++; //a 값을 넣고 증가, 결국 data 값은 10 이 됨


	data = 0;
	data--;



	//논리 연산자
	// !(역)(참을 거짓으로 거짓을 참으로), &&(곱)(AND)(둘다 참일 때 참 둘다 거짓일 때 거짓), ||(합)(OR)
	// 참(true), 거짓(false)

	// 참   : 0이 아닌 값, 주로 1
	// 거짓 : 0

	// 키워드로 제공해줌
	//true;
	//false;

	//int trueflase = true; // 1을 넣겠다

	
	bool truefalse = false;
	bool IsTrue = 100;
	// 0만 아니면 참


	IsTrue = true;
	IsTrue = !IsTrue;

	int iTrue = 100;
	iTrue = !iTrue;


	iTrue = 100 && 200;  // 참
	iTrue = 0 && 200; // 거짓

	iTrue = 0 || 300; // 참
	iTrue = 0 || 0; // 거짓


	// 구문
	// if, else
	// switch case



	// 삼항 연산자
	// :?










	return 0;


}
